mod common;

use crate::common::FromClientMessage;
use message_io::network::{NetEvent, Transport};
use message_io::node::{self, NodeEvent};
use std::time::Duration;

enum Signal {
    Greet,
    // Any other app event here.
}

fn main() {
    let args: Vec<String> = std::env::args().collect();

    let (handler, listener) = node::split();

    let (server, _) = handler
        .network()
        .connect(Transport::FramedTcp, "127.0.0.1:3042")
        .unwrap();

    listener.for_each(move |event| match event {
        NodeEvent::Network(net_event) => match net_event {
            NetEvent::Connected(_endpoint, _ok) => handler.signals().send(Signal::Greet),
            NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
            NetEvent::Message(_endpoint, data) => {
                println!("Received: {}", String::from_utf8_lossy(data));
            }
            NetEvent::Disconnected(_endpoint) => (),
        },
        NodeEvent::Signal(signal) => match signal {
            Signal::Greet => {
                let message = FromClientMessage::Chat("ha".to_string());
                let output_data = bincode::serialize(&message).unwrap();
                handler.network().send(server, &output_data);
                handler
                    .signals()
                    .send_with_timer(Signal::Greet, Duration::from_secs(1));
            }
        },
    });
}
